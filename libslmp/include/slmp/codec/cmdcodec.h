/**
 * \file cmdcodec.h
 *
 * \brief Command codec.
 *
 * A command encoding function is declared as
 * \code
 * size_t slmp_encode_<COMMAND STRUCT NAME>(
 *     slmp_cmd_hdr_t* hdr,
 *     uint8_t* stream,
 *     int type);
 * \endcode
 * where `hdr` points to the command struct that is to be encoded into a
 * packet stream. When `stream` is not NULL, it points to a buffer whose
 * capacity is large enough to hold the packet stream. If `stream` is NULL, 
 * the function returns minimum buffer length required to hold the encoded
 * packet stream. Parameter `type` specifies the packet stream type which can
 * be either ASCII or binary. If the function succeeds, the return value is 
 * the number of bytes written to the stream. If the function fails, it 
 * returns a value of 0. Typical usage of command encoding functions is to 
 * call the function twice, first by passing `stream` argument with NULL to 
 * get the minimum byte length of the buffer required, then allocate that 
 * size of memory or more and call the function again passing `stream` with
 * the address of memory allocated.
 * \code
 *  int type = SLMP_BINARY_STREAM;
 *  size_t buf_len = slmp_encode_xxxxx((slmp_cmd_hdr_t*)(pcmd), NULL, type);
 *  uint8_t *stream = malloc(buf_len);
 *  if (!stream) {
 *      ****** Run out of memory.
 *  }
 *  else if (slmp_encode_xxxxx((slmp_cmd_hdr_t*)(pcmd), stream, type) 
 *      != buf_len)
 *  {
 *      ****** Failed to encode.
 *      int err = slmp_get_errno();
 *      fprintf(stderr, slmp_get_err_msg(err));
 *  }
 *  else {
 *      ****** Succeeds.
 *  }
 * \endcode
 *
 * A command decoding function is declared as
 * \code
 * slmp_cmd_hdr_t* slmp_decode_<COMMAND STRUCT NAME>(
 *     uint8_t* stream,
 *     size_t len,
 *     int type,
 *     int addr_width);
 * \endcode
 * where `stream` and `type` has the same meaning as they are in encoding 
 * functions. `len` indicates the length of the stream. `addr_width` 
 * indicates the address width used by the command. If the function succeeds, 
 * it returns a pointer to the decoded command struct. If the function fails,
 * it returns a NULL pointer. The pointer returned should be freed by 
 * invoking slmp_free() function.
 * \code
 *  pcmd = (slmp_xxxxxx_t*)slmp_decode_xxxxxx(stream, len, SLMP_BINARY_STREAM,
 *      SLMP_ADDRESS_16BIT);
 *  if (!pcmd) {
 *      ****** Failed to decode.
 *      int err = slmp_get_errno();
 *      fprintf(stderr, slmp_get_err_msg(err));
 *  }
 *  else {
 *      ****** Have fun with pcmd and finally...
 *      slmp_free(pcmd);
 *  }
 * \endcode
 *
 * Other header files included in this directory are generated by CCGEN program.
 *
 * \author Neucrede <neucrede@sina.com>
 * \version 1.0
 * \copyright BSD 2-Clause License
 */

#ifndef __CMDCODEC_H__
#define __CMDCODEC_H__

#include "slmp/slmpapi.h"
#include "slmp/command/cmdhdr.h"

#ifdef __cplusplus
extern "C" {
#endif

/** Command encoding function pointer type. */
typedef size_t (SLMPCALL *slmp_command_encode_t)(slmp_cmd_hdr_t* /* hdr */, 
    uint8_t* /* stream */, int /* type */);

/** Command decoding function pointer type. */
typedef slmp_cmd_hdr_t* (SLMPCALL *slmp_command_decode_t)(
    uint8_t* /* stream */, size_t /* len */, int /* type */, 
    int /* addr_width */);

/**
 * \brief Encode an array into byte stream.
 *
 * \param[in] array Pointer to the array.
 * \param[in] elem_size Element size. Valid sizes are 1, 2, and 4.
 * \param[in] n Number of elements.
 * \param[in] stream Pointer to the stream buffer. If it is setted to NULL,
 * no actual encoding will be performed except for returning the minimum byte
 * length required for the stream buffer.
 * \param[in] type Stream type. Either `SLMP_BINARY_STREAM` or
 * `SLMP_ASCII_STREAM`.
 *
 * \return If the function succeeds, it returns the length of the stream. 
 * If the function fails, the function returns a value of zero. Call
 * slmp_get_errno() to get the error number.
 */
SLMPAPI size_t SLMPCALL slmp_encode_array(
    void *array, size_t elem_size, size_t n, uint8_t *stream, int type);

/**
 * \brief Decode array from byte stream.
 *
 * \param[in] stream Byte stream.
 * \param[in] len Length of the stream.
 * \param[in] elem_size Element size. Valid sizes are 1, 2, and 4.
 * \param[in] type Stream type. Either `SLMP_BINARY_STREAM` or
 * `SLMP_ASCII_STREAM`.
 *
 * \return If the function succeeds, it returns the pointer to the decoded array.
 * If the function fails, the function returns a value of NULL. Call
 * slmp_get_errno() to get the error number.
 *
 * \remarks Free returned array pointer by calling slmp_free()
 * after use.
 *
 */
SLMPAPI void* SLMPCALL slmp_decode_array(
    uint8_t *stream, size_t len, size_t elem_size, int type);

#ifdef __cplusplus
}
#endif


/* Internal Memory (Device) */
#include "intmem_codec.h"

/* Dual Port Memory (Memory) */
#include "dpmem_codec.h"

/* Extension Module (ExtendUnit) */
#include "extunit_codec.h"

/* Remote Control */
#include "remctrl_codec.h"

/* Remote Password (Password) */
#include "rempswd_codec.h"

/* File */
#include "filecmd_codec.h"

/* Loopback Test (SelfTest) */
#include "selftest_codec.h"

/* Clear Error */
#include "clearerr_codec.h"

/* Node Connection */
#include "nodeconn_codec.h"

/* Node Monitoring */
#include "nodemon_codec.h"

/* Parameter Setting */
#include "paramset_codec.h"

#endif /* __CMDCODEC_H__ */
